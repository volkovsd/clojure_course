# clojure_course

This is my review of Clojure

Examples of Clojure code, which show the basics of language

Clojure

атомарные значения
коллекции

Пространство имен - это фундаментальная единица структуризации программного кода в языке Clojure
Весь программный код clojure определяется и вычисляется внутри пространства имён.
Понятие "пространство имён" аналогично понятию packages в Java или Module в Oberon.
Пространство имён связывает между собой символы, переменные или импортированные Java-классы.
 

программный код состоит из выражений
каждое выражение возвращает единственное значение

В Clojure нет инструкций не возвращающих значений,
таких как if, for, continue, которые используются
для управления потоком выполнения программы.
В Clojure все языковые конструкции являются выражениями,
которые выозвращают единственное значение.

В Clojure формы управления потоком выполнения, включая if и when,
возвращают значения, как и любые другие выражения


Списки
Символы
выражения, которые возвращают буквальные значения,
которые они (выражения) определяют.

Правило в Clojure:
Первое значение в списке является оператором,
остальные значения - параметрами этого оператора.

Особенность Clojure - homoiconicity (гомоиконность):
Формат записи выполняемого кода совпадает с форматом записи данных,
т.е. код-это-данные.
Это означает, что программы на Clojure могут использоваться
для создания и преобразования других программ на языке Clojure.
Это свойство является основой механизма макросов
- инструмента метапрограммирования на языке Clojure.

С практической точки зрения прямое соответствие между кодом и данными означает,
что код на языке Clojure в REPL и в исходном файле, не является текстом,
так как программирование выполняется с приминением литералов структур данных языка Clojure.


<code>
(defn avarage
    [numbers]
    (/ (apply + numbers)(count numbers)))
</code>

или

<code>
(defn avarage [numbers] (/ (apply + numbers)(count numbers)))
</code>

Код Clojure - это не текст, который преобразуется в функцию avarage.
Это - структура данных списка /(+ 1 2 3) или ([]())/, которая содержит четыре символа:
символ defn
символ avarage,
вектор [], который содержит символ numbers
список, который описывает тело функции.
После обработки этого списка будет определена функция avarage

Коллекции - ?

Основная структура программы:
Списки  - ()
Вектора - []
        - {}


Скалярные литералы

Скалярные литералы - это синтаксис представления значений,
которые не являются коллекцией.

Строки - это Java строки
Логические значения - true, false
nil
Знаки (characters) - символьные литералы
Ключевые слова (keywords) - означают сами себя.
Ключевые слова используются как средства доступа к значениям
всегда начинаются с двоеточия, например :name
в коллекциях и типах - ассоциативные массивы и записи:

код

(defn person {:name "John Smith" :city "New-York, NY"})
или
(defn person {:name "John Smith"
              :city "New-York, NY"})

repl => (:city person)

"New-York, NY"

Создаётся ассоциативный массив с двумя элементами:
:name
:city

В REPL выполняется поиск по ключу :city
Такой возможно, потому что ключевые слова - это функции,
которые находят сами себя в коллекциях,
которые передаются в аргументах этой функции.

Ключевые слова - это разновидность "именнованых" значений,
потому что они имееют встроенные имена,
которые доступны при помощи функции name, встроены в пространства имен,
поступны при помощи функции namespace.
Ключевые слова - это идентификаторы, которые доступны в пределах коллекций,
т.е. ассоциативных массивов и записей.

Symbols (символы) - тоже разновидность именнованных значений
Символы - это идентификаторы, которы действуют в пределах всей среды выполнения Clojure
К символам относятся также и переменные (vars), которые являются именнованными блоками памяти
для хранения функций и данных, Java-классы, локальные ссылки и т.д.

(average[60 80 100 120])

В данном случае average - это символ, ссылка на функцию, которая хранится в переменной с именем average.
Символы начинаются с нечислового знака, но могут содержать буквы и цифры, а также знаки:
символ нижнего подчеркивания, +, -, *, /, !, ?

Символы со "/" обозначают символы с пространством имён
и соответствуют именнованным значениям в указаном пространстве имён.

Результат интерпретаци символов в сущности, на которые они ссылаются,
зависит от контекста вычислений и пространств имён, которые доступны внутри контекста вычислений.

Синтаксис регулярных выражений в Clojure, точно повторяет синтаксис регулярных выражений в Ruby,
за исключением небольших различий в символях-ограничителях.




























































































































































































































